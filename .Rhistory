XS <- cbind(X2,X3,X4)
#Vetor de valores verdadeiros dos parametros
b <- rbind(beta0,beta1,beta2)
g <- rbind(gamma0,gamma1,gamma2,gamma3)
#Vetor de medias 1
mu1 <- exp(as.numeric(model.matrix(~XO) %*% b))
#Vetor de medias 2
mu2 <- exp(as.numeric(model.matrix(~XS) %*% g))
u1  <-rnorm(n)
u2  <-rnorm(n)
z1  <-(((sqrt(1+rho))+(sqrt(1-rho)))/2)*u1+(((sqrt(1+rho))-(sqrt(1-rho)))/2)*u2
z2  <-(((sqrt(1+rho))-(sqrt(1-rho)))/2)*u1+(((sqrt(1+rho))+(sqrt(1-rho)))/2)*u2
#################################################################
#Vari?veis (T1,T2)~BSB(mu1,phi1,mu2,1,rho)
##########################################################
T1<-(mu1/(1+(1/phi1)))*((1/2)*(sqrt(2/phi1))*z1+sqrt(1+((1/2)*(sqrt(2/phi1))*z1)^2))^2
T2<-(mu2/(1+(1/phi2)))*((1/2)*(sqrt(2/phi2))*z2+sqrt(1+((1/2)*(sqrt(2/phi2))*z2)^2))^2
################################################################
#Vari?vel indicadora
######################################
YS<-1*(T2>1)
#######################################################
#Variavel de interesse cuja densidade eh obtida apartir da distribuicao
#Birnbaum Saunders bivariada, observe que esta eh uma variavel com censura
#e de acordo com a minha especificacao dos parametros a censura eh de
#aproximadamente 30%.
############################################################
YO<-T1*YS
## ---- warning = FALSE---------------------------------------------------------
#Data frame com os dados simulados
dt1=data.frame(YO,YS,XO,XS)
names(dt1) <- c("YO","YS","XO1","XO2","XS1","XS2","XS3")
selectionEq <- YS~XS1+XS2+XS3
outcomeEq <- YO~XO1+XO2
mBS <- HeckmanBS(selectionEq,outcomeEq, data=dt1)
#Transformacao de y para ajuste dos demais modelos
l_YO <- ifelse(YS==1,log(YO),0)
#Variavel resposta para ajuste dos demais modelos
dt2=data.frame(l_YO,YS,XO,XS)
names(dt2) <- c("l_YO","YS","XO1","XO2","XS1","XS2","XS3")
selection <- YS~XS1+XS2+XS3
outcome <- l_YO~XO1+XO2
mCL <- HeckmanCL(selection, outcome, data=dt2)
mtS <- HeckmantS(selection, outcome, data=dt2, nu)
mSK <- HeckmanSK(selection, outcome, data=dt2, lambda)
## ----fig3, fig.align= "center", fig.width = 7.2, fig.height= 5, anchor="Figura"----
par(mar=c(2,2,3,0) + 0.9, mgp=c(2,1,0))
library("ggplot2")
library("gridExtra")
barfill <- "grey"
barlines <- "black"
p1 <- ggplot(dt1, aes(YO)) + geom_histogram(aes(y = ..density..), bins=10, colour = barlines, fill = barfill)+
scale_x_continuous(name = "(a) Values of the variable of interest")
#                    breaks = seq(0, 125, 25),
#                    limits=c(0, 125))+
# scale_y_continuous(name = "Count",
#                    breaks = seq(0, 0.01, 0.005),
#                    limits=c(0,  0.01))
p2 <- ggplot(dt2, aes(l_YO)) + geom_histogram(aes(y = ..density..), bins=10, colour = barlines, fill = barfill) + scale_x_continuous(name = "(b) Log of values of variable of interest", limits=c(-5, 5))
#                    breaks = seq(-5, 5, 1),
#                    limits=c(-5, 5))+
# scale_y_continuous(name = "Count",
#                    breaks = seq(0, 1, 0.2),
#                    limits=c(0, 1))
grid.arrange(p1, p2, ncol=2)
# reset to user's options
par(mar = c(5, 4, 4, 2) + 0.1, mgp = c(3, 1, 0))
## -----------------------------------------------------------------------------
Parameters <- c("$\\gamma_{0}$", "$\\gamma_{1}$", "$\\gamma_{2}$", "$\\gamma_{3}$", "$\\beta_{0}$", "$\\beta_{1}$", "$\\beta_{2}$", "$\\phi$", "$\\rho$", "$\\lambda$", "$\\nu$")
truevalue <- c(gamma0, gamma1, gamma2, gamma3, beta0, beta1, beta2, phi1, rho, lambda, nu)
HBS <- round(mBS$coefficients, digits = 3)
HCL <- round(mCL$coefficients, digits = 3)
HSK <- round(mSK$coefficients, digits = 3)
HtS <- round(mtS$coefficients, digits = 3)
Results <- data.frame("Parameters"= Parameters,
"truevalue" = truevalue,
"HeckmanBS" = c(HBS, "NA", "NA"),
"HeckmanCL" = c(HCL, "NA", "NA"),
"HeckmantS" = c(HtS[1:9], "NA", HtS[10]),
"HeckmanSK" = c(HSK[1:9], HSK[10], "NA"))
kable(Results, format = "html", align = c("c", "c", "c", "c", "c"))
#kable_styling(, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = TRUE)
## ----fig4, fig.align= "center", fig.width = 7.2, fig.height= 5, anchor="Figura"----
library(ssmodels)
#Leitura do dados MEPS2001
data(MEPS2001)
#tornando visiveis as colunas do data-frame
attach(MEPS2001)
barfill <- "grey"
barlines <- "black"
p1 <- ggplot(MEPS2001,aes(ambexp))+geom_histogram(colour = barlines, fill = barfill)+
scale_x_continuous(name = "(a) Expenditures Medical",
breaks = seq(0, 15000, 2500),
limits=c(0, 15000))+
scale_y_continuous(name = "Count",
breaks = seq(0, 800, 100),
limits=c(0, 800))
p2 <- ggplot(MEPS2001,aes(lambexp))+geom_histogram(colour = barlines, fill = barfill)+
scale_x_continuous(name = "(b) Log of Expenditures Medical",
breaks = seq(0, 11, 1),
limits=c(0, 11))+
scale_y_continuous(name = "Count",
breaks = seq(0, 300, 100),
limits=c(0, 300))
grid.arrange(p1, p2, ncol=2)
## ---- warning=FALSE-----------------------------------------------------------
selectEq <- dambexp ~ age + female + educ + blhisp + totchr + ins + income
outcomeEq <- lnambx ~ age + female + educ + blhisp + totchr + ins
outcomeS <- cbind(age,female,totchr,ins)
outcomeC <- 1
outcomeBS <- ambexp ~ age + female + educ + blhisp + totchr + ins
mCL <- HeckmanCL(selectEq, outcomeEq, data = MEPS2001)
mBS <- HeckmanBS(selectEq, outcomeBS, data = MEPS2001)
mSK <- HeckmanSK(selectEq, outcomeEq, data = MEPS2001,lambda = 1)
mtS <- HeckmantS(selectEq, outcomeEq, data = MEPS2001,df=12)
mGe <- HeckmanGe(selectEq, outcomeEq,outcomeS, outcomeC, data = MEPS2001)
Parameters <- c("Intercept", "age", "female", "educ", "blhisp", "totchr", "ins", "income",
"Intercept", "age", "female", "educ", "blhisp", "totchr", "ins", "sigma", "age", "female", "totchr", "ins", "rho", "nu", "lambda")
HBS <- round(mBS$coefficients, digits = 3)
HCL <- round(mCL$coefficients, digits = 3)
HSK <- round(mSK$coefficients, digits = 3)
HtS <- round(mtS$coefficients, digits = 3)
HGe <- round(mGe$coefficients, digits = 3)
Results <- data.frame("Parameters"= Parameters,
"HeckmanGe" = c(HGe[1:21], "NA", "NA"),
"HeckmanCL" = c(HCL[1:16], "NA", "NA", "NA", "NA", HCL[17], "NA", "NA"),
"HeckmanBS" = c(HBS[1:16], "NA", "NA", "NA", "NA", HBS[17], "NA", "NA"),
"HeckmantS" = c(HtS[1:16], "NA", "NA", "NA", "NA", HtS[17:18], "NA" ),
"HeckmanSK" = c(HSK[1:16], "NA", "NA", "NA", "NA", HSK[17], "NA", HSK[18]))
kable(Results, format = "html", align = c("c", "c", "c", "c", "c"))
## ---- warning=FALSE-----------------------------------------------------------
summary(mCL)
## ---- warning=FALSE-----------------------------------------------------------
summary(mGe)
## ---- warning=FALSE-----------------------------------------------------------
summary(mBS)
## ---- warning=FALSE-----------------------------------------------------------
summary(mtS)
## ---- warning=FALSE-----------------------------------------------------------
summary(mSK)
## ---- warning=FALSE-----------------------------------------------------------
library(ssmodels)
data(nhanes)
attach(nhanes)
perc <- function(x,data){
nna <- ifelse(sum(is.na(x))!=0,summary(x)[[7]],0)
perc <- ifelse(sum(is.na(x))!=0,(nna/length(data$id))*100,0)
return(perc)
}
Variables <- c("SBP (mm Hg)", "Age (year)", "Gender", "BMI (Kg/$m^{2}$)", "Education (years)", "Race", "Income ($\\$1000$ per year)", "Numbers Obs.")
perc1 <- round(perc(sbp,nhanes), digits = 2)
perc2 <- round(perc(age,nhanes), digits = 2)
perc3 <- round(perc(gender,nhanes), digits = 2)
perc4 <- round(perc(bmi,nhanes), digits = 2)
perc5 <- round(perc(educ,nhanes), digits = 2)
perc6 <- round(perc(race,nhanes), digits = 2)
perc7 <- round(perc(Income,nhanes), digits = 2)
nObs <- length(Income)
Percentage <- c(perc1, perc2, perc3, perc4, perc5, perc6, perc7, nObs)
df <- subset(nhanes, !is.na(sbp))
df <- subset(df, !is.na(bmi))
attach(df)
perc11 <- round(perc(sbp,df), digits = 2)
perc12 <- round(perc(age,df), digits = 2)
perc13 <- round(perc(gender,df), digits = 2)
perc14 <- round(perc(bmi,df), digits = 2)
perc15 <- round(perc(educ,df), digits = 2)
perc16 <- round(perc(race,df), digits = 2)
perc17 <- round(perc(Income,df), digits = 2)
nObs1 <- length(Income)
Percentage1 <- c(perc11, perc12, perc13, perc14, perc15, perc16, perc17, nObs1)
table <- data.frame("Variables" = Variables, "Percentage of Missing"= Percentage, "Without Missing"= Percentage1)
kable(table, format = "html", align = c("c", "c", "c"))
## ---- warning=FALSE-----------------------------------------------------------
library("ggplot2")
library("gridExtra")
barfill <- "grey"
barlines <- "black"
p1 <- ggplot(df, aes(Income)) + geom_histogram( breaks = seq(0, 10, 0.5), aes(y = ..density..), colour = barlines, fill = barfill)+
scale_x_continuous(name = "Income",
breaks = seq(0, 10, 2),
limits=c(0, 10))
p2 <- ggplot(df, aes(log(sbp))) + geom_histogram( colour = barlines, fill = barfill) +
scale_x_continuous(name = "Log Systolic blood pressure")
grid.arrange(p1, p2, ncol=2)
## ---- warning = FALSE---------------------------------------------------------
df$YS <- ifelse(is.na(df$Income),0,1)
df$educ <- ifelse(df$educ<=2,0,1)
df$Income <- ifelse(is.na(df$Income),0,df$Income)
attach(df)
selectionEq <- YS~age+gender+educ+race
outcomeEq   <- log(sbp)~age+gender+educ+bmi+Income
outcomeBS   <- sbp~age+gender+educ+bmi+Income
mCL <- HeckmanCL(selectionEq, outcomeEq, data = df)
mBS <- HeckmanBS(selectionEq, outcomeBS, data = df)
mSK <- HeckmanSK(selectionEq, outcomeEq, data = df, lambda = 0)
mtS <- HeckmantS(selectionEq, outcomeEq, data = df, df = 15)
Parameters <- c("Intercept", "age", "gender", "educ", "race", "Intercept", "age", "gender", "educ", "bmi", "income", "sigma", "rho", "nu", "lambda")
HBS <- round(mBS$coefficients, digits = 5)
HCL <- round(mCL$coefficients, digits = 5)
HSK <- round(mSK$coefficients, digits = 5)
HtS <- round(mtS$coefficients, digits = 5)
Results <- data.frame("Parameters"= Parameters,
"HeckmanCL" = c(HCL[1:13], "NA", "NA"),
"HeckmanBS" = c(HBS[1:13], "NA", "NA"),
"HeckmantS" = c(HtS[1:13], HtS[14], "NA"),
"HeckmanSK" = c(HSK[1:13], "NA", HSK[14]))
kable(Results, format = "html", align = c("c", "c", "c", "c", "c"))
## ---- warning = FALSE---------------------------------------------------------
summary(mCL)
## ---- warning = FALSE---------------------------------------------------------
summary(mtS)
## ---- warning = FALSE---------------------------------------------------------
summary(mBS)
## ---- warning = FALSE---------------------------------------------------------
summary(mSK)
```{r, message=FALSE}
library(devtools)
#setwd("~/GitHub")
#create("C:/Users/Dell/Documents/Projetos/3Projetos_de_Pesquisa/2019/ProfMat/Alexandre/statData")
#devtools::setup("C:/Users/Dell/Documents/Projetos/3Projetos_de_Pesquisa/2019/ProfMat/Alexandre/statData")
# install.packages("devtools")
devtools::install_github("fsbmat-ufv/ssmodels")
require(knitr)
require(kfigr)
library(kableExtra)
options(knitr.table.format = "latex")
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", message=FALSE,
warning=FALSE, fig.height=5, fig.width=7.2)
library(ssmodels)
devtools::build_vignettes()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
devtools::check()
library(devtools)
#devtools::install_github("klutometis/roxygen")
library(roxygen2)
devtools::session_info()
devtools::load_all()
devtools::document()
devtools::check()
library(devtools)
#devtools::install_github("klutometis/roxygen")
library(roxygen2)
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
devtools::check()
library(ssmodels)
devtools::load_all()
devtools::document()
library(ssmodels)
devtools::load_all()
devtools::document()
library(ssmodels)
devtools::load_all()
devtools::document()
library(ssmodels)
devtools::load_all()
devtools::document()
library(ssmodels)
devtools::load_all()
devtools::document()
library(ssmodels)
devtools::load_all()
devtools::document()
library(ssmodels)
#' attach(MEPS2001)
#' selectEq <- dambexp ~ age + female + educ + blhisp + totchr + ins + income
#' outcomeBS <- ambexp ~ age + female + educ + blhisp + totchr + ins
#' HeckmanBS(selectEq, outcomeBS, data = MEPS2001)
#' @importFrom Rdpack reprompt
#' @references {
#' \insertAllCited{}
#' }
#' @export HeckmanBS
#' @export
HeckmanBS <- function(selection, outcome, data = sys.frame(sys.parent()), start = NULL) {
##############################################################################
# Extract model matrix and matrix from selection and regression equations
##############################################################################
mf <- match.call(expand.dots = FALSE)
m <- match(c("selection", "data", "subset"), names(mf), 0)
mfS <- mf[c(1, m)]
mfS$drop.unused.levels <- TRUE
mfS$na.action <- na.pass
mfS[[1]] <- as.name("model.frame")
names(mfS)[2] <- "formula"
# model.frame requires the parameter to be 'formula'
mfS <- eval(mfS, parent.frame())
mtS <- terms(mfS)
XS <- model.matrix(mtS, mfS)
NXS <- ncol(XS)
YS <- model.response(mfS)
YSLevels <- levels(as.factor(YS))
#### Regression Matrix
m <- match(c("outcome", "data", "subset", "weights", "offset"), names(mf), 0)
mfO <- mf[c(1, m)]
mfO$na.action <- na.pass
mfO$drop.unused.levels <- TRUE
mfO$na.action <- na.pass
mfO[[1]] <- as.name("model.frame")
names(mfO)[2] <- "formula"
mfO <- eval(mfO, parent.frame())
mtO <- attr(mfO, "terms")
XO <- model.matrix(mtO, mfO)
NXO <- ncol(XO)
YO <- model.response(mfO)
##############################Start#
if (is.null(start))
start <- step2(YS, XS, log(YO), XO)
##### Likelihood#
loglik_BS <- function(par) {
n <- length(YO)
NXS <- dim(model.matrix(~XS))[2] - 1
NXO <- dim(model.matrix(~XO))[2] - 1
## parameter indices
igamma <- 1:NXS
ibeta <- seq(tail(igamma, 1) + 1, length = NXO)
iphi1 <- tail(ibeta, 1) + 1
irho <- tail(iphi1, 1) + 1
gamma <- par[igamma]
beta <- par[ibeta]
phi1 <- par[iphi1]
if (phi1 < 0)
return(NA)
rho <- par[irho]
if ((rho < -1) || (rho > 1))
return(NA)
phi2 <- 1
XS0 <- XS[YS == 0, , drop = FALSE]
XS1 <- XS[YS == 1, , drop = FALSE]
YO[is.na(YO)] <- 0
YO1 <- YO[YS == 1]
XO1 <- XO[YS == 1, , drop = FALSE]
N0 <- sum(YS == 0)
N1 <- sum(YS == 1)
XS0.g <- exp(as.numeric((XS0) %*% gamma))
XS1.g <- exp(as.numeric((XS1) %*% gamma))
XO1.b <- exp(as.numeric((XO1) %*% beta))
term0 <- ((YO1 * (phi1 + 1)/(phi1 * XO1.b))^(1/2) - ((phi1 * XO1.b)/(YO1 *
(phi1 + 1)))^(1/2))
term1 <- exp((-phi1/4) * (term0)^2)
term2 <- (((phi1 + 1)/(phi1 * XO1.b * YO1))^(1/2) + ((phi1 * XO1.b)/((phi1 +
1) * (YO1^3)))^(1/2))
term3 <- (1/(2 * sqrt(2 * pi))) * ((phi1/2)^(1/2))
term4 <- (((phi2 + 1))/(2 * XS1.g * (1 - rho^2)))^(1/2)
term5 <- ((phi2 * XS1.g)/(phi2 + 1)) - 1
term6 <- rho * (phi1/(2 * (1 - rho^2)))^(1/2)
integrand <- term4 * term5 + term6 * term0
term7 <- pnorm(integrand, log.p = TRUE)
term8 <- ((phi2/2)^(1/2)) * (((phi2 + 1)/(phi2 * XS0.g))^(1/2) - ((phi2 *
XS0.g)/(phi2 + 1))^(1/2))
FT2 <- pnorm(term8, log.p = TRUE)
ll <- sum(log(term2) + log(term1) + log(term3) + term7) + sum(FT2)
return(sum(ll))
}
### Gradient #
gradlik_BS <- function(par) {
n <- length(YO)
NXS <- dim(model.matrix(~XS))[2] - 1
NXO <- dim(model.matrix(~XO))[2] - 1
## parameter indices
igamma <- 1:NXS
ibeta <- seq(tail(igamma, 1) + 1, length = NXO)
iphi1 <- tail(ibeta, 1) + 1
irho <- tail(iphi1, 1) + 1
gamma <- par[igamma]
beta <- par[ibeta]
phi1 <- par[iphi1]
nObs <- length(YS)
NO <- length(YS[YS > 0])
nParam <- NXS + NXO + 2
# if(phi1 < 0) return(matrix(NA, nObs, nParam))
rho <- par[irho]
# if( ( rho < -1) || ( rho > 1)) return(matrix(NA, nObs, nParam))
phi2 <- 1
XS0 <- XS[YS == 0, , drop = FALSE]
XS1 <- XS[YS == 1, , drop = FALSE]
YO[is.na(YO)] <- 0
YO1 <- YO[YS == 1]
XO1 <- XO[YS == 1, , drop = FALSE]
N0 <- sum(YS == 0)
N1 <- sum(YS == 1)
XS0.g <- exp(as.numeric((XS0) %*% gamma))
XS1.g <- exp(as.numeric((XS1) %*% gamma))
XO1.b <- exp(as.numeric((XO1) %*% beta))
w <- rep(1, N0 + N1)
w0 <- rep(1, N0)
w1 <- rep(1, N1)
mu1 <- exp(as.numeric((XO) %*% beta))
mu2 <- exp(as.numeric((XS) %*% gamma))
term0 <- ((YO1 * (phi1 + 1)/(phi1 * XO1.b))^(1/2) - ((phi1 * XO1.b)/(YO1 *
(phi1 + 1)))^(1/2))
term1 <- exp((-phi1/4) * (term0)^2)
term2 <- (((phi1 + 1)/(phi1 * XO1.b * YO1))^(1/2) + ((phi1 * XO1.b)/((phi1 +
1) * (YO1^3)))^(1/2))
term3 <- (1/(2 * sqrt(2 * pi))) * ((phi1/2)^(1/2))
term4 <- (((phi2 + 1))/(2 * XS1.g * (1 - rho^2)))^(1/2)
term5 <- ((phi2 * XS1.g)/(phi2 + 1)) - 1
term6 <- rho * (phi1/(2 * (1 - rho^2)))^(1/2)
integrand <- term4 * term5 + term6 * term0
term7 <- pnorm(integrand, log.p = TRUE)
term8 <- ((phi2/2)^(1/2)) * (((phi2 + 1)/(phi2 * XS0.g))^(1/2) - ((phi2 *
XS0.g)/(phi2 + 1))^(1/2))
FT2 <- pnorm(term8, log.p = TRUE)
term9 <- ((-1/2) * (((YO1 * (phi1 + 1))/(phi1 * (XO1.b)))^(1/2) + ((phi1 *
XO1.b)/(YO1 * (phi1 + 1)))^(1/2))) * (XO1)  #Derivada de term0 em relação a beta
term10 <- (1/2) * (((XO1.b * phi1)/((YO1^3) * (phi1 + 1)))^(1/2) - ((phi1 +
1)/(YO1 * phi1 * XO1.b))^(1/2)) * (XO1)  #Derivada de term2 em relação a beta
term11 <- ((-1/2) * (sqrt(phi2/2)) * (((phi2 + 1)/(phi2 * (XS0.g)))^(1/2) +
((phi2 * XS0.g)/((phi2 + 1)))^(1/2))) * (XS0)  #Derivada de term8 em relação a gamma
term12 <- (-1/2) * ((YO1/((phi1^3) * XO1.b * (phi1 + 1)))^(1/2) + (XO1.b/(YO1 *
((phi1 + 1)^3) * phi1))^(1/2))  #Derivada de term0 em relação a phi1
term13 <- (1/2) * ((XO1.b/(phi1 * ((phi1 + 1)^3) * (YO1^3)))^(1/2) - (1/((phi1^3) *
(phi1 + 1) * XO1.b * YO1))^(1/2))  #Derivada de term2 em relação a phi1
term14 <- rho/(2 * ((2 * phi1 * (1 - rho^2))^(1/2)))  #Derivada de term6 em relação a phi1
term15 <- (rho/(1 - rho^2)) * term4  #Derivada de term4 em relação a rho
term16 <- (1/(1 - rho^2)) * ((phi1/(2 * (1 - rho^2)))^(1/2))  #Derivada de term6 em relação a rho
# f1=log(term1), f2=log(term2), f3=log(term3), f4=term7, f5=FT2
lambda_I <- exp(dnorm(integrand, log = TRUE) - pnorm(integrand, log.p = TRUE))
lambda_T8 <- exp(dnorm(term8, log = TRUE) - pnorm(term8, log.p = TRUE))
df1b <- (-phi1/2) * term0 * term9  #Derivada de log(T1) em relação a beta
df2b <- (term10/term2)  #Derivada de log(T2) em relação a beta0
df4b <- lambda_I * term9 * term6  #Derivada de log(T7) em relação a beta
df4g <- lambda_I * ((1/4) * (((XS1.g + 2)/sqrt(XS1.g * (1 - rho^(2)))))) *
(XS1)  #Derivada de f4 em relação a gamma
df5g <- lambda_T8 * term11  #Derivada de FT2 em relação a gamma
df1phi1 <- (-(term0^2)/4) - (phi1/2) * (term0 * term12)  #Derivada do log(T1) em relação a phi1
df2phi1 <- (1/term2) * term13
df3phi1 <- 1/(8 * term3 * ((pi * phi1)^(1/2)))
df4phi1 <- lambda_I * (term0 * term14 + term6 * term12)
df4rho <- lambda_I * (term5 * term4 * (rho/(1 - rho^2)) + (term0 * term6/(rho *
(1 - rho^2))))
gradient <- matrix(0, nObs, nParam)
gradient[YS == 0, igamma] <- w0 * df5g
gradient[YS == 1, igamma] <- w1 * (df4g)
gradient[YS == 1, ibeta] <- w1 * (df1b + df2b + df4b)
gradient[YS == 1, iphi1] <- w1 * (df1phi1 + df2phi1 + df3phi1 + df4phi1)
gradient[YS == 1, irho] <- w1 * (df4rho)
return(colSums(gradient))
}
####### Optim function #
theta_BS <- optim(start,
loglik_BS,
gradlik_BS,
method = "BFGS",
hessian = T,
control = list(fnscale = -1))
############# Results #
names(theta_BS$par) <- c(colnames(XS), colnames(XO), "sigma", "rho")
a   <- start
a1  <- theta_BS$par
a2  <- theta_BS$value
a3  <- theta_BS$counts[2]
a4  <- theta_BS$hessian
a5  <- solve(-a4)
a6  <- sqrt(diag(a5))
a7  <- YSLevels
a8  <- length(YS)
a9  <- length(start)
a10 <- sum(YS == 0)
a11 <- sum(YS == 1)
a12 <- ncol(XS)
a13 <- ncol(XO)
a14 <- (a8-a9)
a15 <- -2*a2 + 2*a9
a16 <- -2*a2 + a9*log(a8)
cl <- class(theta_BS)
result <- list(coefficients=a1,
value         =  a2,
loglik        = -a2,
counts        =  a3,
hessian       =  a4,
fisher_infoBS =  a5,
prop_sigmaBS  =  a6,
level         =  a7,
nObs          =  a8,
nParam        =  a9,
N0            = a10,
N1            = a11,
NXS           = a12,
NXO           = a13,
df            = a14,
aic           = a15,
bic           = a16,
initial.value = a)
class(result) <- c("HeckmanBS", cl)
result
}
devtools::load_all()
devtools::load_all()
library(devtools)
#setwd("~/GitHub")
#create("C:/Users/Dell/Documents/Projetos/3Projetos_de_Pesquisa/2019/ProfMat/Alexandre/statData")
#devtools::setup("C:/Users/Dell/Documents/Projetos/3Projetos_de_Pesquisa/2019/ProfMat/Alexandre/statData")
# install.packages("devtools")
#devtools::install_github("fsbmat-ufv/ssmodels")
devtools::load_all()
devtools::document()
library(ssmodels)
#setwd("~/GitHub")
#create("C:/Users/Dell/Documents/Projetos/3Projetos_de_Pesquisa/2019/ProfMat/Alexandre/statData")
#devtools::setup("C:/Users/Dell/Documents/Projetos/3Projetos_de_Pesquisa/2019/ProfMat/Alexandre/statData")
# install.packages("devtools")
#devtools::install_github("fsbmat-ufv/ssmodels")
devtools::load_all()
devtools::document()
library(ssmodels)
