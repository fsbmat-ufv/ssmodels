}
library(numDeriv)
# Avaliação numérica do gradiente
grad_num <- grad(func = loglik_gen, x = theta_GE)
# Avaliação analítica do gradiente
grad_ana <- gradlik_gen(theta_GE)
# Comparação lado a lado
cbind(Gradiente_Analitico = round(grad_ana, 6),
Gradiente_Numerico  = round(grad_num, 6),
Diferenca           = round(grad_ana - grad_num, 6))
rm(list = ls())
cat("\014")
library(devtools)
library(roxygen2)
library(testthat)
library(tidyverse)
devtools::session_info()       # (opcional) Verifica as versões/carregamento das dependências
devtools::load_all()           # Carrega todas as funções do pacote localmente
devtools::document()
devtools::clean_vignettes()    # Limpa os arquivos temporários das vinhetas (recomendado antes de buildar)
devtools::build_vignettes()    # Compila as vinhetas (gera .html e .R files em inst/doc)
devtools::check()              # Faz todas as checagens formais do pacote (inclui vinhetas, testes, etc.)
################HeckmanGe
data("Mroz87")
Mroz87$lwage <- if_else(Mroz87$wage>0,log(Mroz87$wage), NA)
selection <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
outcome <- lwage ~ educ + exper + I(exper^2)
outcomeS <- cbind(educ, exper)
outcomeC <- cbind(educ, exper)
data <- Mroz87
attach(data)
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- cbind(educ, exper)
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
Mroz87$lwage <- if_else(Mroz87$wage>0,log(Mroz87$wage), NA)
selection <- lfp ~ huswage + kids5 + mtr + fatheduc + educ + city
outcome <- lwage ~ educ+city
outcomeS <- cbind(fatheduc, educ, city)
outcomeC <- 1
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- cbind(educ, exper)
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
summary(theta_GE)
selection <- lfp ~ huswage + kids5 + mtr + fatheduc + educ + city
outcome <- lwage ~ educ+city
Mroz87$lwage <- if_else(Mroz87$wage>0,log(Mroz87$wage), NA)
selection <- lfp ~ huswage + kids5 + mtr + fatheduc + educ + city
outcome <- lwage ~ educ+city
outcomeS <- cbind(fatheduc, educ, city)
outcomeC <- 1
#' selectEq  <- lfp ~ huswage + kids5 + mtr + fatheduc + educ + city
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- cbind(educ, exper)
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
summary(theta_GE)
selection <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
outcome <- lwage ~ educ+city
outcomeS <- cbind(fatheduc, educ, city)
outcomeC <- 1
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- cbind(educ, exper)
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
summary(theta_GE)
selection <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
outcome <- lwage ~ educ + exper + I(exper^2)
outcomeS <- cbind(fatheduc, educ, city)
outcomeC <- 1
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- cbind(educ, exper)
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
summary(theta_GE)
outcomeS <- cbind(educ, exper)
outcomeC <- 1
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- cbind(educ, exper)
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
summary(theta_GE)
outcomeC <- cbind(educ, exper)
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- cbind(educ, exper)
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
components <- extract_model_components(selection = selection,
outcome = outcome,
outcomeS = outcomeS,
outcomeC = outcomeC,
data = data)
XS  <- components$XS       # Model matrix for the selection equation
YS  <- components$YS       # Binary response for the selection equation
NXS <- components$NXS      # Number of selection covariates
XO  <- components$XO       # Model matrix for the outcome equation
YO  <- components$YO       # Response for the outcome equation
NXO <- components$NXO      # Number of outcome covariates
Msigma <- components$Msigma  # Covariates for the scale model
NE <- components$NE          # Number of dispersion parameters
Mrho <- components$Mrho      # Covariates for the correlation model
NV <- components$NV          # Number of correlation parameters
YSLevels <- components$YSLevels  # Levels of the selection variable
XS
YS
NXS
XO
NXS <- ncol(model.matrix(~XS)) - 1
NXO <- ncol(model.matrix(~XO)) - 1
NE <- if (length(outcomeS) == 1) 1 else ncol(model.matrix(~outcomeS))
NV <- if (length(outcomeC) == 1) 1 else ncol(model.matrix(~outcomeC))
Msigma <- if (NE == 1) matrix(1, nrow(XO), 1) else outcomeS
Mrho   <- if (NV == 1) matrix(1, nrow(XO), 1) else outcomeC
## parameter indices
istartS <- 1:NXS
istartO <- (max(istartS) + 1):(max(istartS) + NXO)
ilambda <- (max(istartO) + 1):(max(istartO) + NE)
ikappa  <- (max(ilambda) + 1):(max(ilambda) + NV)
g <- start[istartS]
b <- start[istartO]
start <- c(rep(0, NXS + NXO), 1, 0)
lambda_start <- rep(1, NE)
kappa_start  <- rep(0, NV)
# Starting values for selection (g), outcome (b), scale (sigma) and correlation (rho)
g_start     <- start[1:NXS]
b_start     <- start[(NXS + 1):(NXS + NXO)]
sigma_start <- start[NXS + NXO + 1]  # log(sigma) or intercept
rho_start   <- start[NXS + NXO + 2]  # atanh(rho) or intercept
# Combine all initial values
start <- c(
g_start,
b_start,
if (NE == 1) sigma_start else c(sigma_start, lambda_start),
if (NV == 1) rho_start   else c(rho_start, kappa_start)
)
# Assign names to parameter vector
start_names <- c(
colnames(XS),
colnames(XO),
if (NE == 1) "sigma" else c("interceptS", colnames(outcomeS)),
if (NV == 1) "correlation" else c("interceptC", colnames(outcomeC))
)
names(start) <- start_names
## parameter indices
istartS <- 1:NXS
istartO <- (max(istartS) + 1):(max(istartS) + NXO)
ilambda <- (max(istartO) + 1):(max(istartO) + NE)
ikappa  <- (max(ilambda) + 1):(max(ilambda) + NV)
g <- start[istartS]
b <- start[istartO]
lambda <- start[ilambda]
kappa <- start[ikappa]
mu20 <- as.numeric(XS0 %*% g)
mu21 <- as.numeric(XS1 %*% g)
components <- extract_model_components(selection = selection,
outcome = outcome,
outcomeS = outcomeS,
outcomeC = outcomeC,
data = data)
XS  <- components$XS       # Model matrix for the selection equation
YS  <- components$YS       # Binary response for the selection equation
NXS <- components$NXS      # Number of selection covariates
XO  <- components$XO       # Model matrix for the outcome equation
YO  <- components$YO       # Response for the outcome equation
NXO <- components$NXO      # Number of outcome covariates
Msigma <- components$Msigma  # Covariates for the scale model
NE <- components$NE          # Number of dispersion parameters
Mrho <- components$Mrho      # Covariates for the correlation model
NV <- components$NV          # Number of correlation parameters
YSLevels <- components$YSLevels  # Levels of the selection variable
NXS <- ncol(model.matrix(~XS)) - 1
NXO <- ncol(model.matrix(~XO)) - 1
NE <- if (length(outcomeS) == 1) 1 else ncol(model.matrix(~outcomeS))
NV <- if (length(outcomeC) == 1) 1 else ncol(model.matrix(~outcomeC))
Msigma <- if (NE == 1) matrix(1, nrow(XO), 1) else outcomeS
Mrho   <- if (NV == 1) matrix(1, nrow(XO), 1) else outcomeC
## parameter indices
istartS <- 1:NXS
istartO <- (max(istartS) + 1):(max(istartS) + NXO)
ilambda <- (max(istartO) + 1):(max(istartO) + NE)
ikappa  <- (max(ilambda) + 1):(max(ilambda) + NV)
g <- start[istartS]
b <- start[istartO]
lambda <- start[ilambda]
kappa <- start[ikappa]
mu2 <- XS %*% g
mu1 <- XO %*% b
if (NE == 1) {
sigma <- exp(model.matrix(~1, data = data.frame(rep(1, nrow(XO)))) %*%
lambda)
} else {
sigma <- exp(model.matrix(~Msigma) %*% lambda)
}
if (NV == 1) {
rho <- tanh(model.matrix(~1, data = data.frame(rep(1, nrow(XO)))) %*%
kappa)
} else {
rho <- tanh(model.matrix(~Mrho) %*% kappa)
}
z1 <- YO - mu1
z <- z1 * (1/sigma)
r <- sqrt(1 - rho^2)
A_rho <- 1/r
A_rrho <- rho/r
zeta <- mu2 * A_rho + z * A_rrho
ll <- ifelse(YS == 0, (pnorm(-mu2, log.p = TRUE)), dnorm(z, log = TRUE) -
log(sigma) + (pnorm(zeta, log.p = TRUE)))
sum(ll)
NXS <- ncol(model.matrix(~XS)) - 1
NXO <- ncol(model.matrix(~XO)) - 1
NE <- if (length(outcomeS) == 1) 1 else ncol(model.matrix(~outcomeS))
NV <- if (length(outcomeC) == 1) 1 else ncol(model.matrix(~outcomeC))
Msigma <- if (NE == 1) matrix(1, nrow(XO), 1) else outcomeS
Mrho   <- if (NV == 1) matrix(1, nrow(XO), 1) else outcomeC
nObs <- length(YS)
nParam <- NXS + NXO + NE + NV
XS0 <- XS[YS == 0, , drop = FALSE]
XS1 <- XS[YS == 1, , drop = FALSE]
YO[is.na(YO)] <- 0
YO1 <- YO[YS == 1]
XO1 <- XO[YS == 1, , drop = FALSE]
ES0 <- Msigma[YS == 0, , drop = FALSE]
ES1 <- Msigma[YS == 1, , drop = FALSE]
VS0 <- Mrho[YS == 0, , drop = FALSE]
VS1 <- Mrho[YS == 1, , drop = FALSE]
N0 <- sum(YS == 0)
N1 <- sum(YS == 1)
M1 <- rep(1, N0 + N1)
u1 <- rep(1, N1)  #YS=1
u2 <- rep(1, N0)  #YS=0
## parameter indices
istartS <- 1:NXS
istartO <- (max(istartS) + 1):(max(istartS) + NXO)
ilambda <- (max(istartO) + 1):(max(istartO) + NE)
ikappa  <- (max(ilambda) + 1):(max(ilambda) + NV)
g <- start[istartS]
b <- start[istartO]
lambda <- start[ilambda]
kappa <- start[ikappa]
mu20 <- as.numeric(XS0 %*% g)
mu21 <- as.numeric(XS1 %*% g)
mu11 <- as.numeric(XO1 %*% b)
sigma1 <- as.numeric(exp(model.matrix(if (NE == 1) ~ES1 - 1 else ~ES1) %*% lambda))
rho1   <- as.numeric(tanh(model.matrix(if (NV == 1) ~VS1 - 1 else ~VS1) %*% kappa))
z <- (YO1 - mu11) / sigma1
r <- sqrt(1 - rho1^2)
A_rho <- 1 / r
A_rrho <- rho1 / r
zeta <- drop(mu21) * A_rho + z * A_rrho
MZeta <- exp(dnorm(zeta, log = TRUE) - pnorm(zeta, log.p = TRUE))
Mmu2 <- exp(dnorm(-mu20, log = TRUE) - pnorm(-mu20, log.p = TRUE))
gradient <- matrix(0, nObs, nParam)
gradient[YS == 0, istartS] <- -u2 * XS0 * Mmu2
gradient[YS == 1, istartS] <- u1 * XS1 * MZeta * A_rho
gradient[YS == 1, istartO] <- u1 * XO1 * (z - MZeta * A_rrho) / sigma1
form_sigma <- model.matrix(if (NE == 1) ~ES1 - 1 else ~ES1)
form_rho   <- model.matrix(if (NV == 1) ~VS1 - 1 else ~VS1)
sech_sq <- pracma::sech(form_rho %*% kappa)^2
gradient[YS == 1, ilambda] <- u1 * form_sigma * (z^2 - 1 - MZeta * z * A_rrho)
gradient[YS == 1, ikappa]  <- u1 * form_rho * MZeta * A_rho * sech_sq *
(drop(mu21) * rho1 * A_rho^2 + z * (1 + A_rrho^2))
-u2 * XS0 * Mmu2
u1 * XS1 * MZeta * A_rho
u1 * XO1 * (z - MZeta * A_rrho) / sigma1
form_sigma <- model.matrix(if (NE == 1) ~ES1 - 1 else ~ES1)
form_rho   <- model.matrix(if (NV == 1) ~VS1 - 1 else ~VS1)
sech_sq <- pracma::sech(form_rho %*% kappa)^2
gradient[YS == 1, ilambda] <- u1 * form_sigma * (z^2 - 1 - MZeta * z * A_rrho)
gradient[YS == 1, ikappa]  <- u1 * form_rho * MZeta * A_rho * sech_sq *
(drop(mu21) * rho1 * A_rho^2 + z * (1 + A_rrho^2))
u1
form_rho
MZeta
A_rho
sech_sq
(drop(mu21)
(drop(mu21) * rho1
drop(mu21)
rho1
A_rho
z
A_rrho
u1 * form_rho * MZeta * A_rho * sech_sq *
(drop(mu21) * rho1 * A_rho^2 + z * (1 + A_rrho^2))
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- cbind(exper)
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- 1
data <- Mroz87
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
outcomeC <- 1
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
summary(theta_GE)
outcomeC <- educ
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
outcomeC <- exper
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
outcomeC <- cbind(educ, exper, age)
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- 1
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
outcomeS <- 1
outcomeC <- cbind(educ, exper, age)
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- 1
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
outcomeS <- cbind(educ, exper)
outcomeC <- 1
#' selectEq  <- lfp ~ nwifeinc + educ + exper + I(exper^2) + age + kids5 + kids618
#' outcomeEq <- log(wage) ~ educ + exper + I(exper^2)
#' outcomeS  <- cbind(educ, exper)
#' outcomeC  <- 1
data <- Mroz87
attach(data)
theta_GE <- HeckmanGe(selection, outcome, outcomeS, outcomeC, data = Mroz87)
summary(theta_GE)
theta_GE <- theta_GE$coefficients
components <- extract_model_components(selection = selection,
outcome = outcome,
outcomeS = outcomeS,
outcomeC = outcomeC,
data = data)
XS  <- components$XS       # Model matrix for the selection equation
YS  <- components$YS       # Binary response for the selection equation
NXS <- components$NXS      # Number of selection covariates
XO  <- components$XO       # Model matrix for the outcome equation
YO  <- components$YO       # Response for the outcome equation
NXO <- components$NXO      # Number of outcome covariates
Msigma <- components$Msigma  # Covariates for the scale model
NE <- components$NE          # Number of dispersion parameters
Mrho <- components$Mrho      # Covariates for the correlation model
NV <- components$NV          # Number of correlation parameters
YSLevels <- components$YSLevels  # Levels of the selection variable
##############################################################################
# Log-likelihood function for the generalized Heckman model
##############################################################################
loglik_gen <- function(start) {
NXS <- ncol(model.matrix(~XS)) - 1
NXO <- ncol(model.matrix(~XO)) - 1
NE <- if (length(outcomeS) == 1) 1 else ncol(model.matrix(~outcomeS))
NV <- if (length(outcomeC) == 1) 1 else ncol(model.matrix(~outcomeC))
Msigma <- if (NE == 1) matrix(1, nrow(XO), 1) else outcomeS
Mrho   <- if (NV == 1) matrix(1, nrow(XO), 1) else outcomeC
## parameter indices
istartS <- 1:NXS
istartO <- (max(istartS) + 1):(max(istartS) + NXO)
ilambda <- (max(istartO) + 1):(max(istartO) + NE)
ikappa  <- (max(ilambda) + 1):(max(ilambda) + NV)
g <- start[istartS]
b <- start[istartO]
lambda <- start[ilambda]
kappa <- start[ikappa]
mu2 <- XS %*% g
mu1 <- XO %*% b
if (NE == 1) {
sigma <- exp(model.matrix(~1, data = data.frame(rep(1, nrow(XO)))) %*%
lambda)
} else {
sigma <- exp(model.matrix(~Msigma) %*% lambda)
}
if (NV == 1) {
rho <- tanh(model.matrix(~1, data = data.frame(rep(1, nrow(XO)))) %*%
kappa)
} else {
rho <- tanh(model.matrix(~Mrho) %*% kappa)
}
z1 <- YO - mu1
z <- z1 * (1/sigma)
r <- sqrt(1 - rho^2)
A_rho <- 1/r
A_rrho <- rho/r
zeta <- mu2 * A_rho + z * A_rrho
ll <- ifelse(YS == 0, (pnorm(-mu2, log.p = TRUE)), dnorm(z, log = TRUE) -
log(sigma) + (pnorm(zeta, log.p = TRUE)))
sum(ll)
}
##############################################################################
# Analytical gradient of the log-likelihood
##############################################################################
gradlik_gen <- function(start) {
NXS <- ncol(model.matrix(~XS)) - 1
NXO <- ncol(model.matrix(~XO)) - 1
NE <- if (length(outcomeS) == 1) 1 else ncol(model.matrix(~outcomeS))
NV <- if (length(outcomeC) == 1) 1 else ncol(model.matrix(~outcomeC))
Msigma <- if (NE == 1) matrix(1, nrow(XO), 1) else outcomeS
Mrho   <- if (NV == 1) matrix(1, nrow(XO), 1) else outcomeC
nObs <- length(YS)
nParam <- NXS + NXO + NE + NV
XS0 <- XS[YS == 0, , drop = FALSE]
XS1 <- XS[YS == 1, , drop = FALSE]
YO[is.na(YO)] <- 0
YO1 <- YO[YS == 1]
XO1 <- XO[YS == 1, , drop = FALSE]
ES0 <- Msigma[YS == 0, , drop = FALSE]
ES1 <- Msigma[YS == 1, , drop = FALSE]
VS0 <- Mrho[YS == 0, , drop = FALSE]
VS1 <- Mrho[YS == 1, , drop = FALSE]
N0 <- sum(YS == 0)
N1 <- sum(YS == 1)
M1 <- rep(1, N0 + N1)
u1 <- rep(1, N1)  #YS=1
u2 <- rep(1, N0)  #YS=0
## parameter indices
istartS <- 1:NXS
istartO <- (max(istartS) + 1):(max(istartS) + NXO)
ilambda <- (max(istartO) + 1):(max(istartO) + NE)
ikappa  <- (max(ilambda) + 1):(max(ilambda) + NV)
g <- start[istartS]
b <- start[istartO]
lambda <- start[ilambda]
kappa <- start[ikappa]
mu20 <- as.numeric(XS0 %*% g)
mu21 <- as.numeric(XS1 %*% g)
mu11 <- as.numeric(XO1 %*% b)
sigma1 <- as.numeric(exp(model.matrix(if (NE == 1) ~ES1 - 1 else ~ES1) %*% lambda))
rho1   <- as.numeric(tanh(model.matrix(if (NV == 1) ~VS1 - 1 else ~VS1) %*% kappa))
z <- (YO1 - mu11) / sigma1
r <- sqrt(1 - rho1^2)
A_rho <- 1 / r
A_rrho <- rho1 / r
zeta <- drop(mu21) * A_rho + z * A_rrho
MZeta <- exp(dnorm(zeta, log = TRUE) - pnorm(zeta, log.p = TRUE))
Mmu2 <- exp(dnorm(-mu20, log = TRUE) - pnorm(-mu20, log.p = TRUE))
gradient <- matrix(0, nObs, nParam)
gradient[YS == 0, istartS] <- -u2 * XS0 * Mmu2
gradient[YS == 1, istartS] <- u1 * XS1 * MZeta * A_rho
gradient[YS == 1, istartO] <- u1 * XO1 * (z - MZeta * A_rrho) / sigma1
form_sigma <- model.matrix(if (NE == 1) ~ES1 - 1 else ~ES1)
form_rho   <- model.matrix(if (NV == 1) ~VS1 - 1 else ~VS1)
sech_sq <- pracma::sech(form_rho %*% kappa)^2
gradient[YS == 1, ilambda] <- u1 * form_sigma * (z^2 - 1 - MZeta * z * A_rrho)
gradient[YS == 1, ikappa]  <- u1 * form_rho * MZeta * A_rho * sech_sq *
(drop(mu21) * rho1 * A_rho^2 + z * (1 + A_rrho^2))
colSums(gradient)
}
library(numDeriv)
# Avaliação numérica do gradiente
grad_num <- grad(func = loglik_gen, x = theta_GE)
# Avaliação analítica do gradiente
grad_ana <- gradlik_gen(theta_GE)
# Comparação lado a lado
cbind(Gradiente_Analitico = round(grad_ana, 6),
Gradiente_Numerico  = round(grad_num, 6),
Diferenca           = round(grad_ana - grad_num, 6))
data(Mroz87)
attach(Mroz87)
Mroz87$lwage <- if_else(Mroz87$wage>0,log(Mroz87$wage), NA)
devtools::session_info()       # (opcional) Verifica as versões/carregamento das dependências
devtools::load_all()           # Carrega todas as funções do pacote localmente
devtools::document()           # Atualiza a documentação com base nos arquivos Roxygen2
devtools::clean_vignettes()    # Limpa os arquivos temporários das vinhetas (recomendado antes de buildar)
devtools::build_vignettes()    # Compila as vinhetas (gera .html e .R files em inst/doc)
devtools::check()              # Faz todas as checagens formais do pacote (inclui vinhetas, testes, etc.)
rm(list = ls())
cat("\014")
library(devtools)
library(roxygen2)
library(testthat)
devtools::session_info()       # (opcional) Verifica as versões/carregamento das dependências
devtools::load_all()           # Carrega todas as funções do pacote localmente
devtools::document()           # Atualiza a documentação com base nos arquivos Roxygen2
devtools::clean_vignettes()    # Limpa os arquivos temporários das vinhetas (recomendado antes de buildar)
devtools::build_vignettes()    # Compila as vinhetas (gera .html e .R files em inst/doc)
devtools::check()              # Faz todas as checagens formais do pacote (inclui vinhetas, testes, etc.)
rm(list = ls())
cat("\014")
library(devtools)
library(roxygen2)
library(testthat)
#library(tidyverse)
devtools::session_info()       # (opcional) Verifica as versões/carregamento das dependências
devtools::load_all()           # Carrega todas as funções do pacote localmente
devtools::document()           # Atualiza a documentação com base nos arquivos Roxygen2
devtools::clean_vignettes()    # Limpa os arquivos temporários das vinhetas (recomendado antes de buildar)
devtools::build_vignettes()    # Compila as vinhetas (gera .html e .R files em inst/doc)
devtools::check()
